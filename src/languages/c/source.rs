use crate::types::{ FieldSlot, FieldType, StructMember, UserDefinitionLink};
use crate::RuneFileDescription;
use crate::languages::c::utilities::{ OutputFile, pascal_to_snake_case, pascal_to_uppercase, spaces };
use std::path::Path;

pub fn output_source(file: &RuneFileDescription, output_path: &Path) {

    // Print disclaimers. Requires C23 compliant compiler
    //
    // · Autogenerated code info
    //
    // · Compiler version (C23 compliant)
    //
    // GCC 13 or higher
    // CLang 8.0 or higher
    //
    // —————————————————————————————————————————————————

    let c_file_string: String = format!("{0}/{1}.rune.c", output_path.to_str().unwrap(), file.file_name);

    let mut source_file: OutputFile = OutputFile::new(c_file_string);

    // Disclaimers
    // ————————————

    // ...

    // Include own header
    // ———————————————————

    source_file.add_line(format!("#include \"{0}.rune.h\"", file.file_name));
    source_file.add_newline();

    // Include rune.h
    // ———————————————

    source_file.add_line(format!("#include \"rune.h\""));

    // Struct parsers
    // ———————————————

    for struct_definition in &file.definitions.structs {

        // println!("Parsing {0}", struct_definition.name);

        let struct_name: String = pascal_to_snake_case(&struct_definition.name);

        // SORT BY INDEX; DO NOT FORGET
        // INDEXES MISSING MUST HAVE AN EMPTY DEFINITION --> .size = 0 will cause the field to be skipped

        // Get highest index number (except verification field)
        let mut highest_index: usize   = 0;
        let mut has_verification: bool = false;

        for member in &struct_definition.members {
            match member.field_slot {
                FieldSlot::VerificationField       => has_verification = true,
                FieldSlot::NamedSlot(index) => {
                    if index as usize > highest_index {
                        highest_index = index as usize;
                    }
                }
            }
        }

        let member_count: usize = (highest_index + 1) + (has_verification as usize);

        // Index sort all members, adding empty definitions for skipped fields
        let mut index_sorted_members: Vec<StructMember> = Vec::with_capacity(member_count);

        // Also get longest member name for spacing reasons
        let mut longest_member_name_size: usize = 0;

        for i in 0..member_count  {

            // Empty definition that will be used if index not found in struct list
            let mut member: StructMember = StructMember::index_empty(i);

            // Try to find member with index i
            for listed_member in &struct_definition.members {
                let listed_index: usize = match listed_member.field_slot {
                    FieldSlot::NamedSlot(index) => index,
                    FieldSlot::VerificationField       => highest_index + 1
                };

                if listed_index == i {
                    member = listed_member.clone();

                    if pascal_to_snake_case(&member.ident).len() > longest_member_name_size {
                        longest_member_name_size = pascal_to_snake_case(&member.ident).len()
                    }
                }
            }

            index_sorted_members.push(member);
        }

        let verification_field: String = match has_verification {
            false => String::from("NO_VERIFICATION_FIELD"),
            true  => format!("{0}", member_count - 1)
        };

        source_file.add_newline();
        source_file.add_line(format!("message_parser_t RUNIC_PARSER {0}_parser = {{", struct_name));
        source_file.add_line(format!("    .size               = sizeof({0}_t),", struct_name));
        source_file.add_line(format!("    .largest_field      = {0},", highest_index));
        source_file.add_line(format!("    .verification_index = {0},", verification_field));
        source_file.add_line(format!("    .field_info         = {{"));

        for i in 0..member_count {
            let member_name: String = pascal_to_snake_case(&index_sorted_members[i].ident);
            let spacing: usize      = longest_member_name_size - member_name.len();

           //  println!("Got spacing {0} from longest member size {1}", spacing, longest_member_name_size);

            let init_char: String = match &index_sorted_members[i].field_type {
                FieldType::Empty => String::new(),
                _                => String::from(".")
            };

            let end: char = match i == member_count - 1 {
                false => ',',
                true  => ' '
            };

            let size_string: String = index_sorted_members[i].c_size_definition();

            let verification_string: String = match has_verification && i == member_count - 1 {
                false => String::from(""),
                true  => String::from(" - Verification field")
            };

            let parser_index_string: String = match &index_sorted_members[i].user_definition_link {
                UserDefinitionLink::StructLink(link) => format!("{0}_INDEX", pascal_to_uppercase(&link.name)),
                _ => String::from("NO_PARSER")
            };

            source_file.add_line(format!("        /* {0}{1}: {2}{3}{4} */ {{", init_char, member_name, spaces(spacing), i, verification_string));
            source_file.add_line(format!("            .field_offset       = offsetof({0}_t, {1}),", struct_name, member_name));
            source_file.add_line(format!("            .field_size         = {0},", size_string));
            source_file.add_line(format!("            .parser_array_index = {0}", parser_index_string));

            source_file.add_line(format!("        }}{0}", end));
        }

        source_file.add_line(format!("    }}"));
        source_file.add_line(format!("}};"));
    }

    source_file.output_file();
}
